<?xml version="1.0" encoding="UTF-8"?>
<config>
    <parameters>
        <param key="makeNoNamespaceVersion" value="true"/>
        <param key="purgeWhitespace" value="false()"/>
        <param key="pathToTokenizerLib" value="lib-toks.xsl"/>
        <param key="pathToBoundaryLib" value="lib-bdr.xsl"/>
        <param key="useAbbrList" value="true" as="xs:boolean"/>
        <param key="punctCharPattern" value="[\p{P}-[‘’\-‚]]"/>
        <param key="abbrLexURI"
            value="http://www.linguistics.ruhr-uni-bochum.de/~dipper/software/abbrev.lex"/>
    </parameters>
    <postProcessing>
        <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
            xmlns:xs="http://www.w3.org/2001/XMLSchema"
            xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:tei="http://www.tei-c.org/ns/1.0"
            exclude-result-prefixes="#all" version="2.0">
            <xsl:output method="xml" indent="no"/>

            <xsl:template match="node() | @*" mode="postProcess">
                <xsl:copy>
                    <xsl:apply-templates select="node() | @*" mode="#current"/>
                </xsl:copy>
            </xsl:template>

            <xsl:template
                match="tei:w[matches(.,'^[‚‘].+') and not(preceding-sibling::*[1]/self::lb[@break='no'])]" mode="postProcess">
                <xsl:analyze-string select="." regex="^[‚‘]">
                    <xsl:matching-substring>
                        <tei:pc><xsl:value-of select="."/></tei:pc>
                    </xsl:matching-substring>
                    <xsl:non-matching-substring>
                        <tei:w><xsl:value-of select="."/></tei:w>
                    </xsl:non-matching-substring>
                </xsl:analyze-string>
            </xsl:template>
            
            
            <!-- **** AUSNAHME #2 **** -->
            <!-- In Mercks Wien, Z. 9117 ist ein Leerzeichen in einem sic ('Ca pelle'), das aber d. Token nicht trennen soll... -->
            <!--    
        <choice aac_com="ww; laut ww Caipellen, in unserem Orig.Ca?pellen">
            <sic>Ca pel<lb break="no" type="d"/>len</sic>
            <corr cert="high">Capellen</corr>
        </choice>
    
    soll als <w>Ca pellen</w> tokenisiert werden...
    -->
            <xsl:template match="tei:w[parent::sic and .= 'Ca' and following-sibling::node()[1]/self::tei:seg[@type='whitespace'] and following-sibling::node()[2]/self::tei:w[. = 'pel']]" mode="postProcess">
                <xsl:message select="."/>
                <xsl:copy>
                    <xsl:copy-of select="@* except @part"/>
                    <xsl:attribute name="part">I</xsl:attribute>
                    <xsl:value-of select="concat(.,string-join(following-sibling::node()[position() le 2],''))"/>
                </xsl:copy>
            </xsl:template>
            
            <xsl:template match="tei:seg[@type='whitespace'][preceding-sibling::node()[1]/self::tei:w[. eq 'Ca']][following-sibling::node()[1]/self::tei:w[.='pel']]" mode="postProcess"/>
            
            <xsl:template match="tei:w[.='pel'][preceding-sibling::node()[2]/self::tei:w[. eq 'Ca']][preceding-sibling::node()[1]/self::tei:seg[@type='whitespace']]" mode="postProcess"/>
            
            
            <!-- **** Ausnahme #3 **** -->
            <!-- und der gleiche Fall in der gleichen Zeile noch einmal -->
            <xsl:template match="tei:w[.='GOttes=D'][following-sibling::node()[1]/self::tei:seg[@type='whitespace']][following-sibling::node()[2]/self::tei:w[.='enst']]" mode="postProcess">
                <xsl:message select="."/>
                <xsl:copy>
                    <xsl:copy-of select="@*"/>
                    <xsl:value-of select="concat(.,string-join(following-sibling::node()[position() le 2],''))"/>
                </xsl:copy>
            </xsl:template>
            
            <xsl:template match="tei:seg[@type='whitespace'][preceding-sibling::node()[1]/self::tei:w[.='GOttes=D']][following-sibling::node()[1]/self::tei:w[.='enst']]" mode="postProcess"/>
            <xsl:template match="tei:w[. = 'enst'][preceding-sibling::node()[1]/self::tei:seg[@type='whitespace']][preceding-sibling::node()[2]/self::tei:w[.='GOttes=D']]" mode="postProcess"/>
            
            
            
            
            
            <!-- **** Ausnahme #4 **** -->
            <!-- auch 2 Token, die als 1 tokenisiert sind ... "auff hört" in Z. 9431 -->
            <xsl:template match="tei:w[. = 'auff'][following-sibling::node()[1]/self::tei:seg[@type='whitespace']][following-sibling::node()[2]/self::tei:w[.='hört']]" mode="postProcess">
                <xsl:message select="."/>
                <xsl:copy>
                    <xsl:copy-of select="@*"/>
                    <xsl:value-of select="concat(.,string-join(following-sibling::node()[position() le 2],''))"/>
                </xsl:copy>
            </xsl:template>
            <xsl:template match="tei:seg[@type='whitespace'][preceding-sibling::node()[1]/self::tei:w[. eq 'auff']][following-sibling::node()[1]/self::tei:w[.='hört']]" mode="postProcess"/>
            <xsl:template match="tei:w[.='hört'][preceding-sibling::node()[2]/self::tei:w[. eq 'auff']][preceding-sibling::node()[1]/self::tei:seg[@type='whitespace']]" mode="postProcess"/>
            
            <!-- Ausnahme #5: Mercks Wien, Z. 10715 -->
            <!-- Token "ley/de" geht über <table/> hinaus. -->
            <xsl:template match="tei:w[.='de'][preceding-sibling::node()[1]/self::table[. is root()/TEI/text[1]/body[1]/div[14]/p[6]/table[1]]]" mode="postProcess">
                <xsl:message>Ausnahme #5</xsl:message>
                <xsl:message select="."/>
                <xsl:copy>
                    <xsl:attribute name="part">F</xsl:attribute>
                    <xsl:copy-of select="node()"/>
                </xsl:copy>
            </xsl:template>
            
            <!-- Ausnahme #6: Mercks Wien, Z. 9459 -->
            <xsl:template match="tei:w[. = '‘'][@part='I'][following-sibling::node()[1]/self::seg[. is root()/TEI/text[1]/body[1]/div[12]/p[9]/seg[1]]]" mode="postProcess">
                <xsl:message>Ausnahme #6 (template 1/2)</xsl:message>
                <xsl:message select="."/>
                <!-- part="I" löschen -->
                <xsl:copy>
                    <xsl:copy-of select="@* except @part"/>
                    <xsl:copy-of select="node()"/>
                </xsl:copy>
            </xsl:template>
            <xsl:template match="tei:w[. = 'Tu'][@part='F'][ancestor::seg[. is root()/TEI/text[1]/body[1]/div[12]/p[9]/seg[1]]]" mode="postProcess">
                <!-- part="F" löschen -->
                <xsl:message>Ausnahme #6 (template 2/2)</xsl:message>
                <xsl:message select="."/>
                <xsl:copy>
                    <xsl:copy-of select="@* except @part"/>
                    <xsl:copy-of select="node()"/>
                </xsl:copy>
            </xsl:template>
            
            <!-- Ausnahme #7 -->
            <xsl:template match="tei:w[. = '‘'][@part='I'][following-sibling::node()[1]/self::seg[. is root()/TEI/text[1]/body[1]/div[12]/p[8]/seg[1]]]" mode="postProcess">
                <xsl:message>Ausnahme #7 (template 1/2)</xsl:message>
                <xsl:message select="."/>
                <!-- part="I" löschen -->
                <xsl:copy>
                    <xsl:copy-of select="@* except @part"/>
                    <xsl:copy-of select="node()"/>
                </xsl:copy>
            </xsl:template>
            <xsl:template match="tei:w[. = 'Augustinus'][@part='F'][ancestor::seg[. is root()/TEI/text[1]/body[1]/div[12]/p[8]/seg[1]]]" mode="postProcess">
                <!-- part="F" löschen -->
                <xsl:message>Ausnahme #7 (template 2/2)</xsl:message>
                <xsl:message select="."/>
                <xsl:copy>
                    <xsl:copy-of select="@* except @part"/>
                    <xsl:copy-of select="node()"/>
                </xsl:copy>
            </xsl:template>
            
            <!-- Ausnahme #8 -->
            <xsl:template match="tei:w[. = '‘'][@part='I'][following-sibling::node()[1]/self::seg[. is root()/TEI/text[1]/body[1]/div[10]/p[24]/seg[3]]]" mode="postProcess">
                <xsl:message>Ausnahme #8 (template 1/2)</xsl:message>
                <xsl:message select="."/>
                <!-- part="I" löschen -->
                <xsl:copy>
                    <xsl:copy-of select="@* except @part"/>
                    <xsl:copy-of select="node()"/>
                </xsl:copy>
            </xsl:template>
            <xsl:template match="tei:w[. = 'Bernhardus'][@part='F'][ancestor::seg[. is root()/TEI/text[1]/body[1]/div[10]/p[24]/seg[3]]]" mode="postProcess">
                <!-- part="F" löschen -->
                <xsl:message>Ausnahme #8 (template 2/2)</xsl:message>
                <xsl:message select="."/>
                <xsl:copy>
                    <xsl:copy-of select="@* except @part"/>
                    <xsl:copy-of select="node()"/>
                </xsl:copy>
            </xsl:template>
            
        </xsl:stylesheet>
    </postProcessing>
    <abbreviations>
        <abbr>&amp;c</abbr>
    </abbreviations>
    <namespace prefix="tei">http://www.tei-c.org/ns/1.0</namespace>
    <!-- tags to be ignored by the wrapper/tokenizer. this means that their content won't be tokenized, but they will be copied as-are. This does not mean necessarily that these do not constitute token boundaries.-->
    <ignore>
        <expression>tei:fw</expression>
        <expression>tei:pb</expression>
        <expression>tei:seg[@type='header' or @type='footer']</expression>
        <expression>tei:milestone</expression>
        <expression>tei:corr</expression>
        <expression>tei:reg</expression>
        <expression>tei:note</expression>
    </ignore>
    <!-- 
        in word-tags do not mark token boundaries. the preceding partial token (i.e. one that does *not* end with a blank) and the following partial token (i.e. one that does not start with a blank) will be wrapped by an <w>-tag, including the in-word token.
    -->
    <in-word-tags>
        <expression>tei:lb[@break='no']</expression>
        <expression>tei:seg</expression>
        <expression>tei:supplied</expression>
        <expression>tei:choice</expression>
        <expression>tei:placeName</expression>
    </in-word-tags>
    <!-- floating blocks are chunks of text that are not part of the 
     main text flow (e.g. figures) and to be tokenized for themselves. For example:
        <p>
            <w>This</w>
            <w>can</w>
            <w>get</w>
            <w part="I">some</w>
            <lb/>
            <pb/>
            <figure>
                <graphic>...</graphic>
                <caption>
                    <w part="I">Fig</w>
                    <lb/>
                    <w part="F">ure</w>
                    <w>1</w>
                </caption>
            </figure>
            <w part="F">what</w>
            <w>complicated</w>
            <w>.</w>
        </p>
        
     CAVEAT This implies that a floating block does not begin or end with a partial token, so that the preceding tag <w part="I"> can be unambiguosly connected to the next <w>-tag with part="F" -->
    <floating-blocks>
        <expression>tei:figure</expression>
    </floating-blocks>
</config>
