<?xml version="1.0" encoding="UTF-8"?>
<config>
    <parameters>
        <param key="makeNoNamespaceVersion" value="true"/>
        <param key="purgeWhitespace" value="false()"/>
        <param key="pathToTokenizerLib" value="lib-toks.xsl"/>
        <param key="pathToBoundaryLib" value="lib-bdr.xsl"/>
        <param key="useAbbrList" value="true" as="xs:boolean"/>
        <param key="punctCharPattern" value="[\p{P}-[‘’\-‚]]"/>
        <param key="abbrLexURI"
            value="http://www.linguistics.ruhr-uni-bochum.de/~dipper/software/abbrev.lex"/>
    </parameters>
    <postProcessing>
        <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
            xmlns:xs="http://www.w3.org/2001/XMLSchema"
            xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:tei="http://www.tei-c.org/ns/1.0"
            exclude-result-prefixes="#all" version="2.0">
            <xsl:output method="xml" indent="no"/>

            <xsl:template match="node() | @*" mode="postProcess">
                <xsl:copy>
                    <xsl:apply-templates select="node() | @*" mode="#current"/>
                </xsl:copy>
            </xsl:template>

            <xsl:template
                match="tei:w[matches(.,'^[‚‘].+') and not(preceding-sibling::*[1]/self::lb[@break='no'])]" mode="postProcess">
                <xsl:analyze-string select="." regex="^[‚‘]">
                    <xsl:matching-substring>
                        <tei:pc><xsl:value-of select="."/></tei:pc>
                    </xsl:matching-substring>
                    <xsl:non-matching-substring>
                        <tei:w><xsl:value-of select="."/></tei:w>
                    </xsl:non-matching-substring>
                </xsl:analyze-string>
            </xsl:template>
            
            
            <!-- **** AUSNAHME #2 **** -->
            <!-- In Mercks Wien, Z. 9117 ist ein Leerzeichen in einem sic ('Ca pelle'), das aber d. Token nicht trennen soll... -->
            <!--    
        <choice aac_com="ww; laut ww Caipellen, in unserem Orig.Ca?pellen">
            <sic>Ca pel<lb break="no" type="d"/>len</sic>
            <corr cert="high">Capellen</corr>
        </choice>
    
    soll als <w>Ca pellen</w> tokenisiert werden...
    -->
            <xsl:template match="tei:w[parent::sic and .= 'Ca' and following-sibling::node()[1]/self::tei:seg[@type='whitespace'] and following-sibling::node()[2]/self::tei:w[. = 'pel']]" mode="postProcess">
                <xsl:message select="."/>
                <xsl:copy>
                    <xsl:copy-of select="@*"/>
                    <xsl:value-of select="concat(.,string-join(following-sibling::node()[position() le 2],''))"/>
                </xsl:copy>
            </xsl:template>
            
            <xsl:template match="tei:seg[@type='whitespace'][preceding-sibling::node()[1]/self::tei:w[. eq 'Ca']][following-sibling::node()[1]/self::tei:w[.='pel']]" mode="postProcess"/>
            
            <xsl:template match="tei:w[.='pel'][preceding-sibling::node()[2]/self::tei:w[. eq 'Ca']][preceding-sibling::node()[1]/self::tei:seg[@type='whitespace']]" mode="postProcess"/>
            
            
            <!-- **** Ausnahme #3 **** -->
            <!-- und der gleiche Fall in der gleichen Zeile noch einmal -->
            <xsl:template match="tei:w[.='GOttes=D'][following-sibling::node()[1]/self::tei:seg[@type='whitespace']][following-sibling::node()[2]/self::tei:w[.='enst']]" mode="postProcess">
                <xsl:message select="."/>
                <xsl:copy>
                    <xsl:copy-of select="@*"/>
                    <xsl:value-of select="concat(.,string-join(following-sibling::node()[position() le 2],''))"/>
                </xsl:copy>
            </xsl:template>
            
            <xsl:template match="tei:seg[@type='whitespace'][preceding-sibling::node()[1]/self::tei:w[.='GOttes=D']][following-sibling::node()[1]/self::tei:w[.='enst']]" mode="postProcess"/>
            <xsl:template match="tei:w[. = 'enst'][preceding-sibling::node()[1]/self::tei:seg[@type='whitespace']][preceding-sibling::node()[2]/self::tei:w[.='GOttes=D']]" mode="postProcess"/>
            
            
            
            
            
            <!-- **** Ausnahme #4 **** -->
            <!-- auch 2 Token, die als 1 tokenisiert sind ... "auff hört" in Z. 9431 -->
            <xsl:template match="tei:w[. = 'auff'][following-sibling::node()[1]/self::tei:seg[@type='whitespace']][following-sibling::node()[2]/self::tei:w[.='hört']]" mode="postProcess">
                <xsl:message select="."/>
                <xsl:copy>
                    <xsl:copy-of select="@*"/>
                    <xsl:value-of select="concat(.,string-join(following-sibling::node()[position() le 2],''))"/>
                </xsl:copy>
            </xsl:template>
            <xsl:template match="tei:seg[@type='whitespace'][preceding-sibling::node()[1]/self::tei:w[. eq 'auff']][following-sibling::node()[1]/self::tei:w[.='hört']]" mode="postProcess"/>
            <xsl:template match="tei:w[.='hört'][preceding-sibling::node()[2]/self::tei:w[. eq 'auff']][preceding-sibling::node()[1]/self::tei:seg[@type='whitespace']]" mode="postProcess"/>
            
        </xsl:stylesheet>
    </postProcessing>
    <abbreviations>
        <abbr>&amp;c</abbr>
    </abbreviations>
    <namespace prefix="tei">http://www.tei-c.org/ns/1.0</namespace>
    <!-- tags to be ignored by the wrapper/tokenizer. this means that their content won't be tokenized, but they will be copied as-are. This does not mean necessarily that these do not constitute token boundaries.-->
    <ignore>
        <expression>tei:fw</expression>
        <expression>tei:pb</expression>
        <expression>tei:seg[@type='header' or @type='footer']</expression>
        <expression>tei:milestone</expression>
        <expression>tei:corr</expression>
        <expression>tei:reg</expression>
        <expression>tei:note</expression>
    </ignore>
    <!-- 
        in word-tags do not mark token boundaries. the preceding partial token (i.e. one that does *not* end with a blank) and the following partial token (i.e. one that does not start with a blank) will be wrapped by an <w>-tag, including the in-word token.
    -->
    <in-word-tags>
        <expression>tei:lb[@break='no']</expression>
        <expression>tei:seg</expression>
        <expression>tei:supplied</expression>
        <expression>tei:choice</expression>
        <expression>tei:placeName</expression>
    </in-word-tags>
</config>
